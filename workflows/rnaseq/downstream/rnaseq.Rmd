---
output:
    html_document:
        code_folding: hide
        toc: true
        toc_float: true
        toc_depth: 3
---

```{r, include=FALSE}
# Each named chunk has a corresponding entry at:
#
#   https://lcdb.github.io/lcdb-wf/rnaseq-rmarkdown-docs.html
```

```{r global_options, include=FALSE}
# Sets up global options for rendering RMarkdown into HTML.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#global_options
knitr::opts_chunk$set(
    warning=FALSE,
    message=FALSE,
    cache.extra_file_dep_1=file.info('../config/sampletable.tsv')$mtime,
    cache.extra_file_dep_2 = file.info('../data/rnaseq_aggregation/featurecounts.txt')$mtime,
    cache.extra_file_dep_2 = file.info('../data/rnaseq_samples/*/*.kallisto/abundance.h5')$mtime
)
```

# Changelog

**Initial results**

Last run: `r date()`

# RNA-seq results

```{r}
library(AnnotationHub)
library(BiocParallel)
library(clusterProfiler)
library(cowplot)
library(DESeq2)
library(dplyr)
library(DT)
library(genefilter)
library(ggplot2)
library(gridExtra)
library(plotly)
library(ReactomePA)
library(readr)
library(reshape)
library(tibble)
library(tximport)
library(UpSetR)
```


```{r load_helpers}
# Load the lcdbwf R package, which is stored locally
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#load_helpers

devtools::document('../../../lib/lcdbwf')
devtools::load_all('../../../lib/lcdbwf')
```

```{r annotationhub_setup}
# Load the annotations for the specified organism (the "OrgDb")
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#annotationhub_setup
annotation_genus_species <- 'Drosophila melanogaster'
annotation_key_override <- NA
hub.cache <- '../../../include/AnnotationHubCache'
orgdb <- get.orgdb(
    annotation_genus_species,
    cache=hub.cache,
    annotation_key_override=annotation_key_override
)
```

```{r coldata_setup}
# Set up all of the metadata for the samples and experimental design.
#
# This will likely need substantial editing.
#
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#coldata_setup
sample.table.filename <- '../config/sampletable.tsv'
strip.dotted.version <- TRUE
exclude.for.printing <- c('featurecounts.path', 'salmon.path', 'kallisto.path', 'orig_filename', 'orig_filename_R2')
salmon.path.func <- function (x) file.path('..', 'data', 'rnaseq_samples', x, paste0(x, '.salmon'), 'quant.sf')
kallisto.path.func <- function (x) file.path('..', 'data', 'rnaseq_samples', x, paste0(x, '.kallisto'), 'abundance.h5')

colData <- read.table(sample.table.filename, sep='\t', header=TRUE, stringsAsFactors=FALSE)

colData$salmon.path <- sapply(colData$samplename, salmon.path.func)
colData$kallisto.path <- sapply(colData$samplename, kallisto.path.func)

factor.columns <- c('group')
for (col in factor.columns){
    colData[[col]] <- as.factor(colData[[col]])
}

colData$group <- relevel(colData$group, ref='control')
rownames(colData) <- colData[,1]
```

## Experiment overview

Here is the sample table with metadata used for this analysis:

```{r}
knitr::kable(colData[, colnames(colData)[!colnames(colData) %in% exclude.for.printing]])
```

```{r salmon, cache=TRUE, eval=FALSE}
# Load salmon quantification.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#salmon
salmon.txi <- tximport(colData[, 'salmon.path'], type='salmon', txOut=TRUE)
salmon.tpm <- salmon.txi$abundance
colnames(salmon.tpm) <- colData$samplename
```

```{r kallisto, cache=TRUE, eval=FALSE, cache.lazy=FALSE}
# Load kallisto quantification.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#kallisto
kallisto.txi <- tximport(colData[, 'kallisto.path'], type='kallisto', txOut=TRUE)
kallisto.tpm <- kallisto.txi$abundance
colnames(kallisto.tpm) <- colData$samplename
```

```{r salmonddstxi, cache=TRUE, eval=FALSE}
# Convert salmon quantification into transcript-level DESeq2 object, and do
# variance-stabilizing transform.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#ddstxi

dds.salmon.txi <- DESeqDataSetFromTximport(
    salmon.txi, colData=colData[, -grepl('path', colnames(colData)), drop=FALSE],
    design=~group
)

vsd.salmon.txi <- varianceStabilizingTransformation(dds.salmon.txi, blind=TRUE)
```

```{r kallistoddstxi, cache=TRUE, eval=FALSE}
# Convert kallisto quantification into transcript-level DESeq2 object, and do
# variance-stabilizing transform.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#ddstxi

dds.kallisto.txi <- DESeqDataSetFromTximport(
    kallisto.txi, colData=colData[, -grepl('path', colnames(colData)), drop=FALSE],
    design=~group
)

vsd.kallisto.txi <- varianceStabilizingTransformation(dds.kallisto.txi, blind=TRUE)
```


```{r dds_initial, cache=TRUE}
# Convert featureCounts gene-level counts into DESeq2 object, and run
# variance-stabiliizing transform.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#dds_initial

dds <- lcdbwf::DESeqDataSetFromCombinedFeatureCounts(
    '../data/rnaseq_aggregation/featurecounts.txt',
    sampletable=colData,
    design=~group)

# NOTE: collapse technical replicates ----------------------------------------
#   If collapsing technical replicates, do so here
# dds <- lcdbwf::collapseReplicates2(dds, dds$biorep)

if (strip.dotted.version){
    rownames(dds) <- sapply(strsplit(rownames(dds), '.', fixed=TRUE),
                            function (x) {ifelse(grepl('_', x[2]),
                                                 paste(x[1], x[2], sep='.'),
                                                 x[1])}
                            )
}

vsd <- varianceStabilizingTransformation(dds, blind=TRUE)
```

## Sample clustering and QC

The following heatmap shows a hierarchical clustering of pairwise distances
between samples. Darker blue means less distant (i.e. more similar). In general
we expect to see replicates clustering together and separation of treatments.

## Clustered heatmap

```{r sample_heatmap, cache=TRUE, dependson='dds_initial'}
# Plot a clustered heatmap of sample distances, for QC.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#sample_heatmap
lcdbwf::plot.heatmap(vsd, colData, cols.for.grouping=c('group'))
```

## PCA {.tabset}

Another way of looking at sample clustering is principal components analysis
(PCA). The x- and y-axes do not have units, rather, they represent the
dimensions along which the samples vary the most. The amount of variance
explained by each principal component is indicated in the axes label.


```{r pca, results='asis', cache=TRUE, dependson='dds_initial'}
# Plot PCA plots, optionally tabbed with different factors colored, for QC.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#pca

groups <- list(
               group=c('group'),
               layout=c('layout')
               )

p <- list()
for(group in groups){
    p[[group]] <- lcdbwf::plotPCA.ly(vsd, intgroup=group)
}

i <- 1; lcdbwf::mdcat('### ', names(p)[i]); ggplotly(p[[i]])
i <- 2; lcdbwf::mdcat('### ', names(p)[i]); ggplotly(p[[i]])
```


## Size factors {.tabset}
Ideally, all libraries were sequenced to identical depth, in which case all
size factors would be 1.0. In practice, this is almost never the case due to
the difficulties of accurately measuring low concentrations of cDNA. These size
factor estimates are DESeq2's way of showing how sequencing depth varies across
libraries. If some libraries are much higher or lower than
1 then those libraries had dramatically different coverage and we should be
careful about interpreting results.

Size factors are calculated according to the median-ratio method (equation 5 of
[Anders & Huber
2010](http://dx.doi.org/10.1186/gb-2010-11-10-r106)).

These diagnostic plots show the size factors (as a ranked bar plot) and the
relationship between the size factors and the total read count (as
a scatterplot).

```{r sizefactors, results='asis'}
# Plot size factors vs total read counts for QC.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#sizefactors

cat('\n\n\n\n\n\n')
lcdbwf::mdcat('### Size factors')
dds <- estimateSizeFactors(dds)
sf <- sizeFactors(dds)
sf <- sf[order(sf)] %>%
        enframe(value = 'Size Factor')

p <- ggplot(sf) +
    aes(x=reorder(name, `Size Factor`), y=`Size Factor`) +
    xlab('sample name') +
    geom_col() +
    theme_bw() +
    theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1))
ggplotly(p)
cat('\n\n\n\n\n\n')

lcdbwf::mdcat('### Size factors vs total read count')
trc <- colSums(counts(dds)) %>%
        enframe(value = 'Total Read Count')
trc_vs_sf <- full_join(sf, trc, by='name')
p <- ggplot(data=trc_vs_sf, aes_string(x="`Total Read Count`", y="`Size Factor`", label='name')) +
    geom_point(size=3) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
ggplotly(p)
cat('\n\n\n\n\n\n')
```

```{r parallel_config}
# Configure whether or not to run DESeq2 in parallel. Take care in setting on
# a cluster.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#parallel_config

parallel <- FALSE
# register(MulticoreParam(4))
```

```{r dds_list, cache=TRUE}
# Create a list of dds objects used as the basis for differential expression.
#
# May need substantial editing.
#
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#dds_list

lst <- list(
            main=list(
                sampletable=colData,
                design=~group),
            no_rep4=list(
                sampletable=colData %>% filter(samplename != 'sample4'),
                design=~group,
                args=list(subset.counts=TRUE)
            )
)
dds.list <- map(lst, lcdbwf::make.dds, salmon.files=NULL, remove.version=TRUE,
                combine.by=NULL, parallel=parallel)
```

```{r siglevel, cache=TRUE}
# NOTE: significance level---------------------------------------------------
alpha <- 0.1
lfc.thresh <- 0 # Must change if using an lfcThreshold other than 0
```

```{r results_01, dependson=c('dds_list', 'siglevel'), cache=TRUE}
# Perform differential expression testing.
#
# This will need substantial editing.
#
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#results

contr_main <- list(
    res=lfcShrink(
        dds.list[['main']],
        contrast=c('group', 'treatment', 'control'),
        type='normal'),
        parallel=parallel,
        dds='main',
        label='Using a log2FoldChange threshold of 0'
)
```

```{r results_02, dependson=c('dds_list', 'siglevel'), cache=TRUE}
# NOTE: Example contrast #2----------------------------------------------------
#    Using the example data, this compares treatment group to control group but
#    requiring genes to have >4-fold differences (log2(4) = 2). Change to
#    reflect your experiment.
#    If using an lfcThreshold, must update elsewhere throughout the code.
res.lfcthresh.2 <- results(
    dds.list[['main']],
    contrast=c('group', 'treatment', 'control'),
    lfcThreshold=2)

contr_lfc2 <- list(
    res=lfcShrink(
        dds.list[['main']],
        contrast=c('group', 'treatment', 'control'),
        parallel=parallel,
        res=res.lfcthresh.2,
        type='normal'
    ),
    dds='main',
    label='Using a log2FoldChange threshold of >2'
)
```

```{r assemble_variables, dependson=c('results', 'results2'), cache=TRUE}
# NOTE: Add a new dependson for every contrast chunk to prevent this from
# malfunctioning.
# res.list is a named list. Each item should be a list with names c('res',
# 'dds', 'label'). "res" is a DESeqResults object, "dds" is the corresponding
# DESeq object the results were extracted from, and "label" is a nicer label to
# use for headers and other text.
res.list <- list()

# Take all the contrast variables and accumulate them into the res.list
contrast_list <- ls()[grepl("contr_+", ls())]
res.list  <- map(contrast_list, function(x) eval(parse(text=x)))
res_names <- map(contrast_list, function(x) str_replace(x, "contr_[A-z]_", ""))
names(res.list) <- res_names
```


```{r attach, cache=TRUE, dependson='results'}
# Attach additional info to the results
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#attach
keytype <- 'ENSEMBL'
columns <- c('SYMBOL', 'UNIPROT', 'ALIAS')

for (name in names(res.list)){
    res.list[[name]][['res']] <- attach.info(
        res.list[[name]][['res']],
        keytype=keytype,
        columns=columns)
}
```

# Differential expression {.tabset}

```{r}
# NOTE: significance level---------------------------------------------------
alpha <- 0.1
lfc.thresh <- 0 # Must change if using an lfcThreshold other than 0
```

Here is a table summarizing the comparisons. See the [Background and
help](#Help) section for details.

```{r, results='asis'}
knitr::kable(summarize.res.list(res.list, alpha, lfc.thresh, dds.list))
```

For each comparison there is a tab and under each tab are the following:

- summary of results (the line from the summary table above for this comparison)
- Normalized counts plots for the top 3 upregulated genes
- Normalized counts plots for the top 3 down-regulated genes
- an M-A plot
- a p-value histogram


See the [Background and help](#Help) section for details on these.


```{r reportresults, results='asis'}
# Generate a tabset for each set of results that contains a nested set of tabs
# of various output.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#reportresults

# NOTE: Which columns to add to the top plots' titles?-------------------------
#    This will add nicer titles to the plots. These may have come from the
#    `attach.info` call above.
add_cols <- c('symbol', 'alias')

for (name in names(res.list)){
  dds.i <- dds.list[[ res.list[[name]][['dds']] ]]
  res.i <- res.list[[name]][['res']]
  label <- res.list[[name]][['label']]

  mdcat('## ', label, ' {.tabset}')
  mdcat('### Summary of results')
  print(knitr::kable(my.summary(res.i, dds.i)))
  mdcat('### Normalized counts of top 3 upregulated genes')
  print(lcdbwf::counts.plot(lcdbwf::counts.df(dds.i, res.i, sel.genes=lfc.filter(res.i),
                              label='symbol', rank.col='padj'),
                    3))
  mdcat('### Normalized counts of top 3 downregulated genes')
  print(lcdbwf::counts.plot(lcdbwf::counts.df(dds.i, res.i, sel.genes=lfc.filter(res.i, reverse=TRUE),
                              label='symbol', rank.col='padj'),
                    3))

  # NOTE: gene labels --------------------------------------------------------
  #   By default we plot the symbols of the top 10 upregulated or downregulated
  #   genes, with the lowest padj. To change this behavior edit the following
  #   lines
  res.i <- res.i[order(res.i$padj),]

  genes.to.label <- res.i[1:10, 'symbol']

  mdcat('### M-A plot')
  print(plotMA.label(res.i, genes.to.label=genes.to.label, col='symbol'))

  mdcat('### P-value distribution')
  pval.hist(res.i)
}
```

```{r selections, cache=TRUE, dependson='attach'}
# Make selections of interesting sets of genes to be investigated further.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#selections
sel.list <- list()
for (name in names(res.list)){
  res <- res.list[[name]][['res']]


  # NOTE: any other selections?------------------------------------------------
  #    Here we just get the up- and downregulated genes, but any arbitrary
  #    subsets of the results can be added.
  #
  #    For each selection:
  #      - TSV of the subset of genes will be written to file and a link
  #        created for it in the Markdown
  #      - GO analysis will be performed on each group separately below.
  sel.list[[name]] <- list(
    up=res[get.sig(res, alpha=alpha, lfc.thresh=lfc.thresh, direction='up'),],
    dn=res[get.sig(res, alpha=alpha, lfc.thresh=lfc.thresh, direction='dn'),]
    )
}

# Keep track of our sel.list entries, here just using the last one
sel.names <- names(sel.list[[name]])
```

```{r upsetplots, results='asis', cache=TRUE, dependson='selections'}
# Compare overlap across multiple differential expression contrasts.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#upsetplots
#
# UpSet plots only make sense for more than one set of genes. The Markdown
# explanatory text and the plots themselves are only created if res.list has
# multiple items in it.

plot.upset <- function(sel.list.key, label) {
    mdcat("## UpSet plot: ", label)
    ll <- lapply(sel.list, function (x) rownames(x[[sel.list.key]]))
    ll <- ll[lapply(ll, length) > 0]
    if (length(ll) > 1) {
        print(upset(fromList(ll), order.by='freq', nsets=length(ll)))
        outfile <- file.path('upset_plots', paste0(label, '.tsv'))
        lldf <- rownames.first.col(fromList.with.names(ll))
        write.table(lldf, file=outfile, sep='\t', row.names=FALSE)
        mdcat('- [', outfile, ']', '(', outfile, ')')
        pdf.file <- file.path('upset_plots', paste0(label, '.pdf'))
        dev.copy(pdf, file=pdf.file)
        dev.off()
        mdcat('- [', pdf.file, ']', '(', pdf.file, ')')

    } else {
        mdcat('not enough contrasts with upregulated genes')
    }
}


if (length(res.list) > 1){

    dir.create('upset_plots', showWarnings=FALSE)

    mdcat("# UpSet plots {.tabset}")
    mdcat("Here we gather together all the interesting gene sets into an ",
          "[UpSet plot](http://caleydo.org/tools/upset/). These plots show ",
          "the combinatorial overlaps of genes found to be up or down ",
          "across the different contrasts performed. It's much like a ",
          "Venn diagram, but easier to interpret and can scale to many comparisons. ",
          "A TSV file is linked under each plot. This file has rows for each ",
          "gene and columns for each contrast. A `1` indicates that gene was found to be ",
          "up/down/changed in that contrast. "
    )

    for (name in names(sel.list[[1]])){
        plot.upset(name, name)
    }
}
```

```{r genepatterns, child='gene-patterns.Rmd', eval=TRUE}
# Run the gene patterns module (see other Rmd for details).
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#genepatterns
rmarkdown::render('gene-patterns.Rmd', run_pandoc=FALSE)
```

# Exported results

The files below are TSVs that can be opened in Excel:


```{r, results='asis'}
# Write out files for full and each selection, and create a link to them in the
# HTML generated by this RMarkdown.
for (name in names(res.list)){
  mdcat('## ', res.list[[name]][['label']])
  fn <- paste0(name, '.tsv')
  write.table(res.list[[name]][['res']], file=fn, row.names=FALSE, sep='\t', quote=FALSE)
  mdcat('- [', fn, '](', fn, '), results for ', res.list[[name]][['label']])
}
```

```{r functionalenrichment, child='functional-enrichment.Rmd', eval=TRUE}
# Perform functional enrichment for all of the sets of selected genes.
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#functionalenrichment

rmarkdown::render('functional-enrichment.Rmd', run_pandoc=FALSE)
```

# Session info
For reproducibility purposes, here is the output of `sessionInfo()` showing the
versions of all packages used here.

```{r, collapse=FALSE}
sessionInfo()
```

# Help

```{r helpdocs, child="help_docs.Rmd", run_pandoc=FALSE}
# Include the help text, useful for first-time collaborators.
#
# Docs: https://lcdb.github.io/lcdb-wf/rnaseq-rmd.html#helpdocs
# NOTE: optional help section--------------------------------------------------
#   Delete this chunk, or set to eval=FALSE, if you don't want to include the
#   help text from "help_docs.Rmd"
```
